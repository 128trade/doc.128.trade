(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{348:function(e,t,a){"use strict";a.r(t);var i=a(28),n=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_4-trading-engine"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-trading-engine"}},[e._v("#")]),e._v(" 4. Trading Engine")]),e._v(" "),t("p",[e._v("The core of 128.trade is its Trading Engine, a high-performance, deterministic execution environment that supports spot markets, perpetual contracts, hierarchical accounts and subaccounts, and verifiable state transitions. While the design draws inspiration from modern high-performance venues such as Hyperliquid and Aster, the engine extends these paradigms with a Byzantine-Fault-Tolerant (BFT) node network, deterministic audit logs, and a progressive roadmap toward zero-knowledge verification of execution.")]),e._v(" "),t("h2",{attrs:{id:"_4-1-accounts-sub-accounts-and-market-support"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-accounts-sub-accounts-and-market-support"}},[e._v("#")]),e._v(" 4.1 Accounts, Sub-Accounts, and Market Support")]),e._v(" "),t("p",[e._v("The engine supports spot and perpetual markets and provides a hierarchical account structure. Sub-accounts allow for logical separation of strategies or risk pools under a master account. Clients may:")]),e._v(" "),t("ul",[t("li",[e._v("place or cancel spot orders,")]),e._v(" "),t("li",[e._v("open or close perpetual positions,")]),e._v(" "),t("li",[e._v("query market, account, or position states,")]),e._v(" "),t("li",[e._v("execute algorithmic or automated trading strategies.")])]),e._v(" "),t("p",[e._v("These capabilities are available uniformly regardless of how a request enters the engine (API or on-chain), ensuring consistent semantics across access modes.")]),e._v(" "),t("h2",{attrs:{id:"_4-2-request-ingestion-and-authentication"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-request-ingestion-and-authentication"}},[e._v("#")]),e._v(" 4.2 Request Ingestion and Authentication")]),e._v(" "),t("p",[e._v("Although Section 3 describes the two high-level access modes (direct API access and oracle-based contract access), the Trading Engine itself abstracts over these differences. Internally, every action is processed as a canonical engine request. The ingestion pipeline verifies request provenance, authenticity, and sequencing through two complementary validation mechanisms:")]),e._v(" "),t("h3",{attrs:{id:"api-origin-requests-signature-based-authentication"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-origin-requests-signature-based-authentication"}},[e._v("#")]),e._v(" API-Origin Requests (Signature-Based Authentication)")]),e._v(" "),t("p",[e._v("Clients integrating via REST/WebSocket must sign each operation using registered keypairs. The engine validates:")]),e._v(" "),t("ul",[t("li",[e._v("request signatures and key ownership,")]),e._v(" "),t("li",[e._v("nonces and replay protection,")]),e._v(" "),t("li",[e._v("account-level permissions and role scopes,")]),e._v(" "),t("li",[e._v("rate limits and throttling rules.")])]),e._v(" "),t("p",[e._v("Only authenticated requests enter the engine's canonical request queue.")]),e._v(" "),t("h3",{attrs:{id:"on-chain-origin-requests-gateway-provenance-verification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#on-chain-origin-requests-gateway-provenance-verification"}},[e._v("#")]),e._v(" On-Chain-Origin Requests (Gateway-Provenance Verification)")]),e._v(" "),t("p",[e._v("Requests submitted via gateway contracts undergo an alternative verification pipeline. The engine validates:")]),e._v(" "),t("ul",[t("li",[e._v("the gateway contract address and chain identifier,")]),e._v(" "),t("li",[e._v("block-header inclusion or light-client verification of emitted gateway events,")]),e._v(" "),t("li",[e._v("relayer signature bundles or TEE attestations,")]),e._v(" "),t("li",[e._v("canonical encoding of parameters and idempotency markers.")])]),e._v(" "),t("p",[e._v("This ensures that cross-chain requests reflect genuine on-chain intent and prevents forged or replayed messages.")]),e._v(" "),t("h3",{attrs:{id:"unified-request-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unified-request-queue"}},[e._v("#")]),e._v(" Unified Request Queue")]),e._v(" "),t("p",[e._v("After authentication, all requests—API or on-chain—enter the same deterministic request queue. This guarantees that:")]),e._v(" "),t("ul",[t("li",[e._v("identical execution logic applies to both modalities,")]),e._v(" "),t("li",[e._v("liquidity and state transitions are fully shared,")]),e._v(" "),t("li",[e._v("no ordering or settlement differences arise between access paths.")])]),e._v(" "),t("h2",{attrs:{id:"_4-3-bft-multi-node-network-and-deterministic-execution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-bft-multi-node-network-and-deterministic-execution"}},[e._v("#")]),e._v(" 4.3 BFT Multi-Node Network and Deterministic Execution")]),e._v(" "),t("p",[e._v("To provide decentralised integrity and auditability, the Trading Engine executes within a distributed BFT network of matching/risk nodes. Each state transition (order placement, matching, fills, margining, funding payments, liquidations) is processed deterministically and committed to an append-only execution log. Because the engine is deterministic, any auditor can replay the log from genesis and reconstruct the full state exactly.")]),e._v(" "),t("p",[e._v("This deterministic audit trail is fundamental for transparency, interoperability and eventual zero-knowledge verification.")]),e._v(" "),t("h2",{attrs:{id:"_4-4-enhancement-roadmap-tee-and-zk-proofs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-enhancement-roadmap-tee-and-zk-proofs"}},[e._v("#")]),e._v(" 4.4 Enhancement Roadmap: TEE and ZK Proofs")]),e._v(" "),t("p",[e._v("The engine supports a long-term trust-minimisation trajectory:")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Phase 1: TEE-Hardened Execution")]),e._v(". Matching nodes may run inside hardware-secured TEEs. Remote attestation allows the Oracle Services module and external verifiers to confirm that the correct engine binary and configuration are executing.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Phase 2: ZK-Proof Generation")]),e._v(". Over time, the engine will output zero-knowledge proofs for each batch of trades, demonstrating that:"),t("br"),e._v('\n"Given the previous state and the submitted orders, the new state was computed exactly according to public rules."'),t("br"),e._v("\nSuch proofs enable external systems, including on-chain contracts, to verify correctness without trusting operator nodes.")])])]),e._v(" "),t("h2",{attrs:{id:"_4-5-risk-engine-liquidation-and-auditability"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-risk-engine-liquidation-and-auditability"}},[e._v("#")]),e._v(" 4.5 Risk Engine, Liquidation, and Auditability")]),e._v(" "),t("p",[e._v("The risk module continuously evaluates each account's collateral ratio, exposure, leverage and funding accruals. When thresholds are breached, deterministic liquidation procedures are triggered and committed to the execution log. Because the log is append-only and replayable, it supports:")]),e._v(" "),t("ul",[t("li",[e._v("forensic analysis,")]),e._v(" "),t("li",[e._v("regulatory or protocol-level audits,")]),e._v(" "),t("li",[e._v("state reconstruction by new nodes,")]),e._v(" "),t("li",[e._v("verifiable cross-chain settlement via Oracle Services.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);