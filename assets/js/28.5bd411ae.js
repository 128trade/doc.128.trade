(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{347:function(e,t,a){"use strict";a.r(t);var n=a(28),i=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_5-oracle-services"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-oracle-services"}},[e._v("#")]),e._v(" 5. Oracle Services")]),e._v(" "),t("p",[e._v("The Oracle Services module constitutes the access and cross-chain messaging layer of 128.trade. Because smart contracts cannot interact directly with an off-chain high-performance engine, this module provides the infrastructure required to transport requests from heterogeneous chains to the Trading Engine and to return authenticated, verifiable execution results back on-chain. It consists of four coordinated subcomponents: gateway contracts, a decentralised relayer network, callback and proof-verification logic, and the asset-mapping interface—which together expose the engine as a contract-callable execution primitive for the multi-chain DeFi ecosystem.")]),e._v(" "),t("h2",{attrs:{id:"_5-1-overview-and-design-goals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-overview-and-design-goals"}},[e._v("#")]),e._v(" 5.1 Overview and Design Goals")]),e._v(" "),t("p",[e._v("The Oracle Services layer is designed around four primary goals:")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Any-chain programmability")]),e._v(". Smart contracts on heterogeneous chains must be able to invoke the Trading Engine as if it were a native module, without introducing new trust assumptions or bespoke bridging interfaces.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Verifiable correctness")]),e._v(". Returned results must be accompanied by proof bundles that allow the gateway contract to verify that off-chain execution was performed faithfully and deterministically.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Deterministic and replay-safe integration")]),e._v(". Each request is uniquely identified, idempotent and safely sequenced, ensuring consistent state updates across chains.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("High throughput and asynchronous workflows")]),e._v(". The messaging layer must support concurrent requests, pipelined callbacks and scalable multi-chain operation.")])])]),e._v(" "),t("p",[e._v("To realise these goals, Oracle Services comprise four coordinated submodules:")]),e._v(" "),t("ol",[t("li",[e._v("Gateway Contracts (on-chain access layer),")]),e._v(" "),t("li",[e._v("Relayer Network (off-chain messaging and validation layer),")]),e._v(" "),t("li",[e._v("Callback & Proof Verification Logic (on-chain authenticity enforcement),")]),e._v(" "),t("li",[e._v("Asset Mapping & Settlement Interface (representation and settlement of engine-native state across chains).")])]),e._v(" "),t("h2",{attrs:{id:"_5-2-request-lifecycle-from-on-chain-intent-to-verified-execution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-request-lifecycle-from-on-chain-intent-to-verified-execution"}},[e._v("#")]),e._v(" 5.2 Request Lifecycle: From On-Chain Intent to Verified Execution")]),e._v(" "),t("p",[e._v("The end-to-end lifecycle linking an on-chain contract to the Trading Engine proceeds through the following verifiable stages:")]),e._v(" "),t("ol",[t("li",[t("p",[t("strong",[e._v("On-chain request initiation")]),e._v(". A contract on chain X calls a gateway "),t("code",[e._v("request()")]),e._v(" function (e.g., "),t("code",[e._v("requestOpenPosition")]),e._v("), which generates a unique "),t("code",[e._v("requestId")]),e._v(". The gateway emits an event encoding parameters, chain context and caller metadata.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Relayer event detection and provenance validation")]),e._v(". The decentralised relayer network monitors gateway events, verifies origin-chain metadata and optional light-client proofs, and constructs a canonical request payload for off-chain execution.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Delivery to the Trading Engine")]),e._v(". Relayers submit the validated request to the engine through authenticated channels. The engine authenticates the message and inserts it into its deterministic execution queue.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Engine execution and result generation")]),e._v(". The Trading Engine processes the request, matching, margining, funding, liquidating or settling as appropriate, and outputs a deterministic execution result and associated batch identifier.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Proof generation and attestation")]),e._v(". Relayers collectively generate a proof bundle attesting to the correctness of the engine result. This bundle may include threshold signatures, TEE attestation metadata, or future ZK proofs generated from the engine's deterministic audit log.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Callback delivery to chain X")]),e._v(". A relayer (or any permissionless actor) submits the proof-backed result to the gateway's "),t("code",[e._v("callback()")]),e._v(" function, along with identifiers such as "),t("code",[e._v("requestId")]),e._v(" and "),t("code",[e._v("batchId")]),e._v(".")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Gateway verification and state materialisation")]),e._v(". The gateway verifies the proof bundle, enforces idempotency and replay protection, and applies the result on-chain, minting or transferring position NFTs, updating balances or notifying the invoking contract.")])])]),e._v(" "),t("p",[e._v("This lifecycle ensures that the Trading Engine can be invoked from any chain while maintaining correctness, authenticity and deterministic reconciliation.")]),e._v(" "),t("h2",{attrs:{id:"_5-3-gateway-contracts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-gateway-contracts"}},[e._v("#")]),e._v(" 5.3 Gateway Contracts")]),e._v(" "),t("p",[e._v("Gateway contracts form the canonical on-chain interface to 128.trade. They expose a family of deterministic functions that encode decentralised intent:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("request")]),e._v(" functions such as "),t("code",[e._v("requestPlaceOrder")]),e._v(", which allow smart contracts to initiate engine-side actions;")]),e._v(" "),t("li",[t("code",[e._v("callback")]),e._v(" functions such as "),t("code",[e._v("onOrderResult")]),e._v(", through which verifiable engine results and proof bundles are delivered back on-chain.")])]),e._v(" "),t("p",[e._v("The gateway contract enforces strict checks: correct request identifiers, replay-protection via nonces or "),t("code",[e._v("requestIds")]),e._v(", verification of relayer signatures or threshold signatures, and (where applicable) verification of state roots or proofs from the underlying bridge or light-client. This design ensures that only authorised and valid results are applied on-chain.")]),e._v(" "),t("h2",{attrs:{id:"_5-4-relayer-network"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-relayer-network"}},[e._v("#")]),e._v(" 5.4 Relayer Network")]),e._v(" "),t("p",[e._v("The decentralised relayer network forms the off-chain messaging and validation layer responsible for transporting requests to the Trading Engine and returning authenticated results. Its responsibilities include provenance verification, request canonicalisation, delivery to the engine, and generation of cryptographic attestations that certify the correctness of the engine's deterministic execution.")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Event observation & provenance validation")]),e._v(". Relayers monitor gateway events across supported chains, verify origin-chain metadata, and (when available) validate light-client or state-root proofs to ensure that the request originated from the correct chain and gateway.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Canonical request construction")]),e._v(". Relayers normalise request parameters, constructing a canonical payload that the Trading Engine can authenticate and execute deterministically.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Authenticated request delivery")]),e._v(". Validated requests are forwarded to the Trading Engine via authenticated channels. Once inside the engine, all requests—API or on-chain—enter the same deterministic execution queue.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Execution-proof generation")]),e._v(". After the engine produces a deterministic result, relayers jointly generate an execution proof bundle that attests to correctness. The proof bundle may be instantiated using multiple verification mechanisms:")]),e._v(" "),t("ul",[t("li",[e._v("Threshold-signature attestation (e.g., M-of-N signatures certifying agreement on engine output);")]),e._v(" "),t("li",[e._v("TEE-based remote attestation (proving the result was generated by an audited engine binary running in a secure enclave);")]),e._v(" "),t("li",[e._v("Light-client provenance proofs (showing the request was included in the canonical chain state);")]),e._v(" "),t("li",[e._v("Zero-knowledge proofs (future extension), generated from the engine's deterministic audit log to prove state transitions without revealing internal data.")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Callback preparation")]),e._v(". Equipped with a valid proof bundle, any relayer (or permissionless actor) can construct and submit a callback transaction to the destination chain.")])])]),e._v(" "),t("p",[e._v("The design follows principles from modern off-chain reporting networks such as Chainlink OCR, but extends them: relayers here certify not just observed data, but the correctness of state transitions performed by a high-performance deterministic execution engine.")]),e._v(" "),t("h2",{attrs:{id:"_5-5-callback-proof-verification-logic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-callback-proof-verification-logic"}},[e._v("#")]),e._v(" 5.5 Callback & Proof Verification Logic")]),e._v(" "),t("p",[e._v("Once a callback transaction carrying an execution proof bundle reaches the gateway contract, verification proceeds entirely on-chain. This separation provides a clean security boundary: relayers produce proofs; gateways verify them.")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Proof-bundle verification")]),e._v(". The gateway verifies the cryptographic proof bundle attached to the execution result. Supported proof types include:")]),e._v(" "),t("ul",[t("li",[e._v("threshold-signature sets (certifying multi-relayer agreement),")]),e._v(" "),t("li",[e._v("TEE attestation metadata (certifying the engine binary and execution environment),")]),e._v(" "),t("li",[e._v("zero-knowledge proofs (certifying state-transition correctness directly from deterministic logs).")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Request and batch integrity")]),e._v(". The gateway checks the "),t("code",[e._v("requestId")]),e._v(", "),t("code",[e._v("batchId")]),e._v(", and canonical payload fields to ensure the callback corresponds exactly to a previously issued request.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Replay protection & idempotency")]),e._v(". State transitions are applied exactly once. Any callback failing nonce or idempotency checks is rejected.")])])]),e._v(" "),t("p",[e._v("Upon successful verification, the gateway materialises the validated result on-chain—for example, minting or updating position NFTs, transferring vault shares, or notifying the invoking contract. This ensures that on-chain state transitions faithfully reflect authenticated deterministic execution of the Trading Engine, even in adversarial conditions.")]),e._v(" "),t("h2",{attrs:{id:"_5-6-asset-mapping-settlement-integration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-asset-mapping-settlement-integration"}},[e._v("#")]),e._v(" 5.6 Asset Mapping & Settlement Integration")]),e._v(" "),t("p",[e._v("The Oracle/Relayer layer also interacts with the asset-mapping system of 128.trade. For example:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Spot assets from various chains may be mapped into the engine as virtual liquidity endpoints; the gateway contract and relayer network ensure the transfer of asset-mapping instructions and settlement notifications.")])]),e._v(" "),t("li",[t("p",[e._v("Perpetual positions (represented as NFTs) may be created or transferred via callback events, with proofs of execution delivered through the oracle network.")])]),e._v(" "),t("li",[t("p",[e._v("Vault shares (ERC-20 tokens) may be minted on chain X after the trading engine executes a vault-subscription request; the relayer network ensures the correct state has been achieved before the minting callback.")])])]),e._v(" "),t("h2",{attrs:{id:"_5-7-safety-and-liveness-guarantees"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-safety-and-liveness-guarantees"}},[e._v("#")]),e._v(" 5.7 Safety and Liveness Guarantees")]),e._v(" "),t("p",[e._v('To ensure robust operation of the oracle/relayer subsystem in 128.trade, we design specific mechanisms that address both safety (i.e., "bad things do not happen") and liveness (i.e., "good things eventually happen") in the context of cross-chain request/response flows. In classical distributed systems literature, safety and liveness are fundamental properties of protocols.')]),e._v(" "),t("h3",{attrs:{id:"fully-permissionless-callback-mechanism"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fully-permissionless-callback-mechanism"}},[e._v("#")]),e._v(" Fully Permissionless Callback Mechanism")]),e._v(" "),t("p",[e._v("Even if the relayer set becomes unavailable or incapacitated (for example by network faults, censorship or operator failure), users on any chain can still complete the request-to-engine workflow and apply the result on-chain. Concretely: when a smart contract on chain X submits a "),t("code",[e._v("request()")]),e._v(" via the gateway contract, the matching/trading engine executes the request and emits a signed or verifiable proof of execution (e.g., threshold-signature, ZK-proof or attested state root). A third-party user or contract may then invoke the "),t("code",[e._v("callback()")]),e._v(" on chain X by presenting the execution result and proof directly, without relying on any designated relayer. This design ensures that funds and positions are not locked indefinitely due to relayer downtime: the safety property holds because only valid proofs are accepted, and liveness is improved because any actor can progress the callback.")]),e._v(" "),t("h3",{attrs:{id:"emergency-exit-via-fraud-proof-roll-up-escape-hatch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#emergency-exit-via-fraud-proof-roll-up-escape-hatch"}},[e._v("#")]),e._v(" Emergency Exit via Fraud-Proof Roll-up Escape Hatch")]),e._v(" "),t("p",[e._v('To further guarantee liveness and protect users in worst-case failures of the engine or the relayer network, we incorporate an emergency escape mechanism akin to optimistic roll-up fraud-proof systems. When a user has placed an order on chain X and the engine or relayer network fails to deliver a callback within a predetermined challenge period, the user may initiate an on-chain "challenge" via the gateway contract:')]),e._v(" "),t("ol",[t("li",[t("p",[e._v("The user submits their "),t("code",[e._v("requestId")]),e._v(", evidence of submission (e.g., event log, timestamp) and a proof that no valid callback has arrived within the window.")])]),e._v(" "),t("li",[t("p",[e._v("If the engine/relayer system does not supply a valid proof of execution within the challenge period, then the gateway contract allows the user to withdraw or reclaim funds/assets through a fallback path.")])])]),e._v(" "),t("p",[e._v("This mechanism ensures that liveness is preserved: honest users will not have funds indefinitely locked; and safety is preserved because the escape path is only triggered if the system fails to deliver a valid execution proof, thereby avoiding unjustified exits.")]),e._v(" "),t("h3",{attrs:{id:"combined-security-guarantees"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#combined-security-guarantees"}},[e._v("#")]),e._v(" Combined Security Guarantees")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Safety")]),e._v(": Only authorised, correctly signed/attested results from the trading engine are accepted. Replay attacks are prevented through unique "),t("code",[e._v("requestId")]),e._v(" and batch identifiers; signature schemes or proof verification ensure authenticity and non-tampering.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Liveness")]),e._v(": The permissionless callback path and the fraud-proof escape mechanism guarantee that, under benign conditions or worst-case failure conditions, users retain the ability to complete their requests or withdraw their assets.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Hybrid trust-minimisation")]),e._v(": While relayers operate for performance and convenience, trust assumptions are minimised. The design does not depend exclusively on a single party or relayer set to sustain functionality.")])])]),e._v(" "),t("p",[e._v("In combination, these mechanisms extend the reliability of the oracle-relayer subsystem beyond typical designs and align with best practices in oracle/liveness research (e.g., ensuring freshness, fallback paths, decentralised relayers).")])])}),[],!1,null,null,null);t.default=i.exports}}]);